# 交易对精度管理模块使用指南

## 概述

`exchange-precision-manager.js` 是一个统一的交易对精度信息管理模块,提供了完整的三级缓存机制和多交易所支持。

## 核心特性

### 1. 三级缓存机制
- **第一级:内存缓存** - 最快,有效期24小时
- **第二级:数据库缓存** - 持久化存储,避免频繁API调用
- **第三级:API获取** - 从交易所API实时获取最新数据

### 2. 多交易所支持
- **Binance**(币安) - 已实现
- **OKX**(欧易) - 待实现
- **Gate.io**(芝麻开门) - 待实现

### 3. 多市场类型支持
- **spot** - 现货市场
- **usdm** - U本位合约市场
- **coinm** - 币本位合约市场

## 使用方法

### 基础用法

```javascript
const precisionManager = require('../utils/exchange-precision-manager.js');

// 获取交易所信息
const exchangeInfo = await precisionManager.getExchangeInfo({
  exchange: 'binance',      // 交易所名称
  marketType: 'usdm',       // 市场类型
  apiKey: 'your_api_key',
  apiSecret: 'your_api_secret'
});
```

### 调整订单数量精度

```javascript
// 方法1: 使用adjustQuantity方法(推荐)
const adjustedQuantity = await precisionManager.adjustQuantity({
  exchange: 'binance',
  marketType: 'usdm',
  symbol: 'BTCUSDT',
  quantity: '0.123456789',
  apiKey: 'your_api_key',
  apiSecret: 'your_api_secret',
  silent: false,              // 是否静默模式(不输出日志)
  operationType: '开仓'        // 操作类型(用于日志)
});

// 方法2: 先获取exchangeInfo,再调整精度
const exchangeInfo = await precisionManager.getExchangeInfo({
  exchange: 'binance',
  marketType: 'usdm',
  apiKey,
  apiSecret
});

const adjustedQuantity = precisionManager.smartAdjustQuantity(
  exchangeInfo, 
  'BTCUSDT', 
  '0.123456789',
  { silent: false, operationType: '开仓' }
);
```

### 在策略插件中使用

```javascript
const precisionManager = require('../utils/exchange-precision-manager.js');

class MyStrategy {
  constructor(options) {
    this.config = options;
  }

  async adjustQuantity(quantity) {
    try {
      return await precisionManager.adjustQuantity({
        exchange: 'binance',
        marketType: 'usdm',
        symbol: this.config.tradingPair,
        quantity: quantity.toString(),
        apiKey: this.config.apiKey,
        apiSecret: this.config.apiSecret,
        silent: false,
        operationType: '网格交易'
      });
    } catch (error) {
      this.logger.error('调整数量精度失败:', error);
      return new bigNumber(quantity).toFixed(8);
    }
  }

  async placeOrder(quantity) {
    const adjustedQuantity = await this.adjustQuantity(quantity);
    // 使用调整后的数量下单
    // ...
  }
}
```

### 在Service层使用

```javascript
const precisionManager = require('../utils/exchange-precision-manager.js');

async function createOrder(apiKey, apiSecret, symbol, quantity) {
  // 调整数量精度
  const adjustedQuantity = await precisionManager.adjustQuantity({
    exchange: 'binance',
    marketType: 'usdm',
    symbol: symbol,
    quantity: quantity.toString(),
    apiKey: apiKey,
    apiSecret: apiSecret,
    operationType: '创建订单'
  });

  // 使用调整后的数量创建订单
  const client = createClient(apiKey, apiSecret);
  return await client.submitNewOrder({
    symbol: symbol,
    side: 'BUY',
    type: 'MARKET',
    quantity: adjustedQuantity
  });
}
```

## 高级功能

### 强制刷新缓存

```javascript
const exchangeInfo = await precisionManager.getExchangeInfo({
  exchange: 'binance',
  marketType: 'usdm',
  apiKey,
  apiSecret,
  forceRefresh: true  // 强制从API重新获取
});
```

### 清除内存缓存

```javascript
// 清除所有内存缓存
precisionManager.clearMemoryCache();

// 清除指定交易所的所有缓存
precisionManager.clearMemoryCache('binance');

// 清除指定交易所和市场类型的缓存
precisionManager.clearMemoryCache('binance', 'usdm');
```

### 获取交易对过滤器信息

```javascript
const exchangeInfo = await precisionManager.getExchangeInfo({
  exchange: 'binance',
  marketType: 'usdm',
  apiKey,
  apiSecret
});

// 获取交易对的所有过滤器
const filters = precisionManager.getSymbolFilters(exchangeInfo, 'BTCUSDT');

// 查找LOT_SIZE过滤器
const lotSizeFilter = filters.find(f => f.filterType === 'LOT_SIZE');
console.log('最小数量:', lotSizeFilter.minQty);
console.log('最大数量:', lotSizeFilter.maxQty);
console.log('步长:', lotSizeFilter.stepSize);
```

### 获取数量精度

```javascript
const precision = precisionManager.getQuantityPrecision(exchangeInfo, 'BTCUSDT');
console.log(`BTCUSDT 数量精度: ${precision} 位小数`);
```

## 数据库结构

### binance_exchange_info 表

| 字段 | 类型 | 说明 |
|------|------|------|
| id | INT | 主键ID |
| exchange | VARCHAR(50) | 交易所名称(binance/okx/gateio) |
| market_type | VARCHAR(50) | 市场类型(spot/usdm/coinm) |
| exchange_info | TEXT | 交易所信息(JSON格式) |
| created_at | DATETIME | 创建时间 |
| updated_at | DATETIME | 更新时间 |

### 索引

- `idx_exchange_market_type`: (exchange, market_type) - 用于快速查询指定交易所和市场类型的数据

## 迁移数据库

如果你的数据库中已有旧数据(没有exchange字段),需要执行迁移:

```bash
# 执行迁移
npx sequelize-cli db:migrate

# 如果需要回滚
npx sequelize-cli db:migrate:undo
```

迁移文件会自动:
1. 添加 `exchange` 字段,默认值为 'binance'
2. 创建 `idx_exchange_market_type` 索引

## 测试

运行测试文件验证功能:

```bash
# 设置环境变量
export BINANCE_API_KEY=your_api_key
export BINANCE_API_SECRET=your_api_secret

# 运行测试
node test/test-exchange-precision-manager.js
```

测试内容包括:
1. 三级缓存机制验证
2. 精度调整功能测试
3. 数据库存储验证
4. 缓存清除和刷新测试

## 性能优化建议

1. **合理使用缓存**: 默认24小时缓存已足够,不要频繁强制刷新
2. **静默模式**: 在高频调用场景使用 `silent: true` 减少日志输出
3. **批量处理**: 如果需要处理多个交易对,先获取一次exchangeInfo,然后复用
4. **错误处理**: 始终添加try-catch,并提供降级方案

## 常见问题

### Q1: 为什么第一次调用很慢?
A: 第一次需要从API获取数据并保存到数据库,后续调用会使用缓存,速度会快很多。

### Q2: 如何确认使用了哪一级缓存?
A: 查看日志输出,会明确标注"从内存缓存获取"、"从数据库缓存获取"或"从API获取"。

### Q3: 数据库缓存什么时候更新?
A: 当数据库中的记录超过24小时时,会在后台自动更新(不阻塞主流程)。

### Q4: 支持其他交易所吗?
A: 目前只实现了Binance,OKX和Gate.io的接口预留了,需要时可以扩展实现。

### Q5: 精度调整失败怎么办?
A: 模块内置了降级方案,如果调整失败会返回默认8位小数精度。

## 与旧代码的对比

### 旧方式(分散在各个plugin中)

```javascript
// 每个plugin都要实现自己的getExchangeInfo
this.getExchangeInfo = async () => {
  if (this.exchangeInfo) return this.exchangeInfo;
  const dbRecord = await db.binance_exchange_info.getLatest();
  if (dbRecord) {
    this.exchangeInfo = JSON.parse(dbRecord.exchange_info);
    return this.exchangeInfo;
  }
  const exchangeInfo = await this.client.getExchangeInfo();
  this.exchangeInfo = exchangeInfo;
  return this.exchangeInfo;
};
```

### 新方式(统一管理)

```javascript
// 所有地方都使用统一的精度管理器
const precisionManager = require('../utils/exchange-precision-manager.js');

const adjustedQuantity = await precisionManager.adjustQuantity({
  exchange: 'binance',
  marketType: 'usdm',
  symbol: this.config.tradingPair,
  quantity: quantity.toString(),
  apiKey: this.config.apiKey,
  apiSecret: this.config.apiSecret
});
```

## 优势

1. **统一管理**: 所有精度相关逻辑集中在一个模块
2. **代码复用**: 避免在多个地方重复实现相同逻辑
3. **易于维护**: 修改精度逻辑只需要改一个地方
4. **扩展性强**: 轻松支持新的交易所和市场类型
5. **性能优化**: 三级缓存机制大幅减少API调用
6. **日志完善**: 详细的日志输出便于调试和监控

## 后续计划

- [ ] 实现OKX交易所支持
- [ ] 实现Gate.io交易所支持
- [ ] 添加价格精度调整功能
- [ ] 添加缓存预热功能
- [ ] 添加监控和告警机制
